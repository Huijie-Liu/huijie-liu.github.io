<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Jay Tech</title>
    <link>//localhost:1313/</link>
    <description>Recent content on Jay Tech</description>
    <image>
      <title>Jay Tech</title>
      <url>//localhost:1313/assets/images/profile.png</url>
      <link>//localhost:1313/assets/images/profile.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 23 May 2024 20:31:53 +0800</lastBuildDate>
    <atom:link href="//localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>3DGS Tutorial</title>
      <link>//localhost:1313/posts/3dgs/</link>
      <pubDate>Thu, 23 May 2024 20:31:53 +0800</pubDate>
      <guid>//localhost:1313/posts/3dgs/</guid>
      <description>3DGS 基本思想 3D高斯分布可以通过它们的各向异性协方差矩阵、位置和透明度等参数来有效地表示复杂场景。由于这些参数是通过机器学习方法进行训练的，渲染阶段无需进行大量处理。因此，它可以利用基于瓦片的光栅化器实现快速渲染，从而在性能上有显著的提升。 创新点 Point-Based Rendering：点基渲染直接将三维空间中的点渲染为图像。 Tiled Rasterization：分块光栅化的基本思想是将屏幕划分为多个小块（Tiles），然后在每个小块内进行相关计算和处理（可微分）。这种方法能够显著减少内存流量，从而提高渲染效率。 Spherical Harmonics：球谐函数是一种在球面上表示函数的方法，特别适用于描述球形表面的光照和阴影效果。 基本流程 收集数据
图像
视频-&amp;gt;ffmpeg截取视频帧
ffmpeg -i &amp;lt;VIDEO_PATH&amp;gt; -qscale:v 1 -qmin 1 -vf fps=2 %04d.jpg 输出如下
📦 $FOLDER_PATH ┣ 📂 input ┃ ┣ 📜 000000.jpg ┃ ┣ 📜 000001.jpg ┃ ┣ 📜 ... 获取相机位姿
COLMAP：开源Structure-from-Motion (SfM) 软件，输入images，输出相机位姿
原论文使用的是自带的convert.py，自动调用COLMAP并转换成需要的格式
桌面软件：RealityCapture, Metashape
移动app：Polycam, Record3D（利用了雷达）
输出如下：
📦 $FOLDER_PATH ┣ 📂 (input) ┣ 📂 (distorted) ┣ 📂 images ┣ 📂 sparse ┃ ┣ 📂 0 ┃ ┃ ┣ 📜 points3D.</description>
    </item>
    <item>
      <title>Recent Advances in Vision Foundation Models</title>
      <link>//localhost:1313/posts/recent-advances-in-vision-foundation-models.assets/</link>
      <pubDate>Thu, 28 Mar 2024 13:30:42 +0800</pubDate>
      <guid>//localhost:1313/posts/recent-advances-in-vision-foundation-models.assets/</guid>
      <description>原文链接
Q1: how to learn image representations? Overview 改进 CLIP 数据层面：Data scaling up 模型层面：Model design image side
FLIP（Scaling CLIP training via masking）：是一种改进的训练方法，用于提高 CLIP模型的训练效率。FLIP 的核心思想是在训练过程中随机遮挡图像的部分区域，只对可见的区域进行编码。
Scaling language-image pre-training via masking, CVPR 2023
language side
K-Lite: 将外部知识融入到对比学习预训练中，在 K-Lite 中，实体的维基百科定义（knowledge）可以与原始的图像替代文本（alt-text）一起自然地用于对比预训练。
K-lite: Learning transferable visual models with external knowledge, NeurIPS 2022
improved interpretability
STAIR（Learning Sparse Text and Image Representation in Grounded Tokens）： 将图像和文本映射到高维稀疏嵌入空间； 每个维度的值是一个非负标量，表示与该维度对应的词或标记的权重； 提供了更好的性能和更清晰地识别图像和文本之间的对应关系； STAIR: Learning Sparse Text and Image Representation in Grounded Tokens, 2023</description>
    </item>
    <item>
      <title>About proxy</title>
      <link>//localhost:1313/posts/proxy/</link>
      <pubDate>Wed, 27 Mar 2024 13:30:42 +0800</pubDate>
      <guid>//localhost:1313/posts/proxy/</guid>
      <description>正向代理 正向代理是客户端和服务器中间的服务器，为了从原始服务器取得内容，客户端向代理服务器发送一个请求并指定目标（原始服务器）， 然后代理服务器向原始服务器转发请求并将获得的内容返回给客户端。
举个例子，比如正常情况下我没法办上youtube，但是我有个aws的机器，它不受GFW的限制，能够访问youtube，我也能正常访问那个aws的机器， 那么我通过发送请求给aws的机器，让他转发我的请求给youtube，然后把youtube返回的数据给我，我就能通过aws的机器作为跳板访问GFW， 那个aws的机器也就是代理服务器的角色，并且这种方式就是正向代理。
总结一下，正向代理就是我想访问一台机器，但是被墙了访问不到，我需要一台机器作为跳板转发我的请求。
反向代理 于正向代理不同，反向代理更多的是为了保护原始服务器。 对于客户端而言，反向代理中的代理服务器就是原始服务器，客户端并不需要知道有这个代理的角色存在， 因此客户端也不需要一些额外的设置，比如正向代理中制定代理服务器是谁。
比如在原始服务器A上配置防火墙，使得只有服务器B能够访问A，并且通过B服务器转发A的数据实现于外界的通信。这样对于客户端，它只需要和B交互， 从而隐藏了服务器A，B服务器也就是反向代理服务器。由于有代理服务器的存在，对于后面的原始服务器来说，也就多了一层做负载均衡的服务器。
透明代理 还有一种代理方式叫做透明代理，比如公司的机器不能上qq，这个就是透明代理，它在内网和外网之间捕捉用户的请求，过滤一部分请求。
SSH端口转发 有一种很简单的方式就能做到代理功能，那就是SSH本身提供的端口转发功能。 要想理解清楚SSH端口转发，首先必须记住这样几个原则：
SSH简单的理解就是2台机器之间安全的数据通道，它包括ssh的client和ssh的server2个角色，这样的一条通道也就是ssh隧道(ssh tunneling) SSH 端口转发自然需要 SSH 连接，而 SSH 连接是有方向的，从 SSH Client 到 SSH Server 我们的应用的请求也是有方向的，一般是客户端向服务器端发出请求 一旦这2个方向相同，我们称为ssh的本地转发(-L)，不同则为远端转发(-R) 命令一般是跑在ssh client的机器上的 本地转发 ssh本地转发命令为：
ssh -L &amp;lt;local port&amp;gt;:&amp;lt;remote host&amp;gt;:&amp;lt;remote port&amp;gt; &amp;lt;SSH hostname&amp;gt; 这条命令可以翻译成：从本地的端口发出请求，通过这台机器作为跳板转发请求到的端口。 是相对而言的，比如是127.0.0.1的话，就是本身。 所以一般如果是127.0.0.1的话，跳板机或者代理服务器就是目标服务器。
举个例子：
A是一台在我家的机器macbook air，它可以访问taobao，也就是服务器C B是一台在公司的机器imac，由于在公司的内网，所以在家的A访问不到B C是taobao的服务器，公司不让上taobao，所以服务器B访问不了C 现在要想在让B服务器能访问C的80端口，由于防火墙这条路本身是走不通的，但是由于B能访问A，A能访问C，所以能把A作为代理服务器实现这一要求。
在服务器B和服务器A之间建立ssh隧道，在SSH端口转发中，由于服务器B能连接到服务器A，并且请求是从服务器B发出，所以B既是ssh的client，也是请求的客户端 所以此时应该在B上去运行ssh的本地转发命令: ssh -L 8080:HOST_C:80 HOST_A
远端转发 ssh远端转发的命令为：
ssh -R &amp;lt;local port&amp;gt;:&amp;lt;remote host&amp;gt;:&amp;lt;remote port&amp;gt; &amp;lt;SSH hostname&amp;gt; 由于本身B是可以访问A的，但是A访问不到B，现在要想服务器A访问到B，也就是在家能连上公司的机器。</description>
    </item>
    <item>
      <title>Fluent Python</title>
      <link>//localhost:1313/posts/fluent-python/</link>
      <pubDate>Mon, 12 Feb 2024 13:30:42 +0800</pubDate>
      <guid>//localhost:1313/posts/fluent-python/</guid>
      <description>Fluent Python Owner: Huijie Liu Tags: Ongoing, Study Note
数据结构 序列构成的数组 Python 标准库用 C 实现了丰富的序列类型，列举如下。
容器序列 list、tuple 和 collections.deque 这些序列能存放不同类型的数据。 扁平序列 str、bytes、bytearray、memoryview 和 array.array，这类序列只能容纳一种类型。 容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列里存放的是值而不是 引用。换句话说，扁平序列其实是一段连续的内存空间。由此可见扁平序列其实更加紧 凑，但是它里面只能存放诸如字符、字节和数值这种基础类型。
序列类型还能按照能否被修改来分类。
可变序列 list、bytearray、array.array、collections.deque 和 memoryview。 不可变序列 tuple、str 和 bytes。 字典和集合 💡 dict 类型是 Python 语言的基石。模块的命名空间、 实例的属性和函数的关键字参数中都可以看到字典的身影。跟它有关的内置函数都在 __builtins__.__dict__ 模块中。 正是因为字典至关重要，Python 对它的实现做了高度优化，而散列表则是字典类型性能出 众的根本原因。集合(set)的实现其实也依赖于散列表。
如果一个对象是可散列的，那么在这个对象的生命周期中，它的散列值是不变的，而且这个对象需要实现 hash() 方法。另外可散列对象还要有 eq() 方法，这样才能跟其他键做比较。如果两个可散列对象是相等的，那么它们的散列值一定是一样的。一般来讲用户自定义的类型的对象都是可散列的。
文本和字节序列 把函数视作对象 💡 可以把函数赋值给变量、传给 其他函数、存储在数据结构中，以及访问函数的属性，供框架和一些工具使用。 一等函数 在 Python 中，函数是一等对象。编程语言理论家把“**一等对象”**定义为满足下述条件的程 序实体:
在运行时创建 能赋值给变量或数据结构中的元素 能作为参数传给函数 能作为函数的返回结果 在 Python 中，整数、字符串和字典都是一等对象。</description>
    </item>
    <item>
      <title>FAQ</title>
      <link>//localhost:1313/faq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/faq/</guid>
      <description>faq</description>
    </item>
  </channel>
</rss>
